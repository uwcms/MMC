/*
 * sdr.c
 *
 *  Created on: Oct 26, 2010
 *      Author: tgorski
 */

#include <stdio.h>
#include <string.h>
#include "swevent.h"
#include "pins.h"
#include "gpio.h"
#include "utils.h"
#include "CTP7_SPI_addrs.h"
#include "nonvolatile.h"
#include "adc.h"
#include "ejecthandle.h"
#include "sensor_svc.h"
#include "eepspi.h"
#include "spi1.h"
#include "fpgaspi.h"
#include "sio_usart.h"
#include "twidriver.h"
#include "ipmi_cmd_parser.h"
#include "payload_mgr.h"
#include "LEDdrivers.h"
#include "math.h"


// Mask bits for sensor updates from hardware drivers
// (new hardware drivers should define additional bits in this mask)
#define   SENS_UPDATE_MSK_INT_ADC               (1 << 0)                    // internal ADC
#define   SENS_UPDATE_MSK_HANDLE                (1 << 1)                    // eject handle

unsigned long sensor_change_mask;

SDR_table_t SDRtbl;

sensor_data_tbl_t SensorData;

PBS_sensor_record_t PBSrecord;

SDR_state_record_t SDRstate;

int event_update_flag;


void internal_ADC_convert_complete(void);
void eject_handle_pos_change(void);
void eject_handle_read(void);
void build_default_SDR_image(void);
void initialize_sensor_table(void);
void calc_adc_readout_scaling_factors(const SDR_type_01h_t* pSDR, front_end_scaling_factors_t *pFEscfac, IPMI_readout_scaling_factors_t* pROscfac, long fullscale_lsb, long fullscale_mV);
float SDR_readout_to_display_val(const SDR_type_01h_t* pSDR, unsigned char readoutval);
unsigned short get_thr_sensor_state(SDR_type_01h_t* pSDR, unsigned short prev_comp_state, unsigned char raw_value);
void process_sensor_events(event_assertion_type_t evtype, int sensornum, unsigned short evtmask);
void Process_Sensors(int sensor_update_flag);
unsigned char get_GPIO_sensor_readout_value(long pinID);
unsigned char get_Alarm_Level_sensor_value(long arg);
void send_threshold_sensor_event(int offsetnum, int sensornum, event_assertion_type_t evtype);
void send_discrete_sensor_event(int offsetnum, int sensornum, event_assertion_type_t evtype);
void payload_based_sensor_read(void);
unsigned char get_pbs_readout_value(long sensornum);


void update_sensor_events(void) {
	// called at initialization and when Set Event Receiver command is issued
  event_update_flag = 1; 	
}


void sensor_svc_init(void) {
  int i1;
  int formatsdreepromimageflag = 0;
  unsigned char curipmbladdr = twi_state.ipmbl_addr;
  unsigned char curentityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  SDR_type_12h_t* pMMCSDR;
  SDR_type_01h_t* pSensSDR;
  

  // read first sdr from EEPROM.  If the record is uninitialized, then the SDR needs to be generated by code and
  // written in entirety to the EEPROM.  If the record is initialized but the slave address in EEPROM doesn't
  // match the slave address stored in EEPROM, then load the SDR from EEPROM, updating the slave address to the
  // correct value in both the SDR table (in RAM) and in EEPROM
  while (eepspi_chk_write_in_progress());			// wait for EEPROM to be available
  pMMCSDR = (SDR_type_12h_t*) &SDRtbl[SDR_MMC];
  eepspi_read((unsigned char*) pMMCSDR, SDR_AREA_BYTE_OFFSET+sizeof(SDR_generic_type_t)*SDR_MMC, sizeof(SDR_type_12h_t));
  if (pMMCSDR->hdr.rectype != 0x12)
    formatsdreepromimageflag = 1;         // SDR space in EEPROM needs formatting
  else {
    // special code for field upgrades to 1.2 from earlier versions of MMC
    // check if SDR is in EEPROM for the payload-based sensors.  If not, reformat the EEPROM
    pSensSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ZYNQ_DIE_TEMP_SENSOR];
    eepspi_read((unsigned char*) pSensSDR, SDR_AREA_BYTE_OFFSET+sizeof(SDR_generic_type_t)*SDR_ZYNQ_DIE_TEMP_SENSOR, sizeof(SDR_type_01h_t));
    if (pSensSDR->hdr.rectype != 0x01)
      formatsdreepromimageflag = 1;       // PBS sensor SDR not found in EEPROM
  }

  if (formatsdreepromimageflag) {
    // build SDR table in code
	  build_default_SDR_image();
	  // write image to EEPROM
	  sio_putstr("Writing default SDR image to EEPROM....\n");
	  eepspi_write((unsigned char *) &SDRtbl, SDR_AREA_BYTE_OFFSET, sizeof(SDR_table_t));
  }
  else {
    // read SDR image from EEPROM
	  eepspi_read((unsigned char *) &SDRtbl, SDR_AREA_BYTE_OFFSET, sizeof(SDR_table_t));
	  // scan read SDR image to determine the number of entries
    // there are simpler ways to do this, but this approach is pretty much bombproof
  }

  // now update all SDR entries with the correct slot-specific information
  for (i1=0; i1<MAX_SDR_REC_CNT; i1++) {
	  switch (SDRtbl[i1].hdr.rectype) {
      case 0x01:        // type 1 SDR record
	      pSensSDR = (SDR_type_01h_t*) &SDRtbl[i1];
		    pSensSDR->ownerID = curipmbladdr;
			  pSensSDR->entityinstance = curentityinstance;
			  break;
			  
	    case 0x12:        // type 12 SDR record
		    pMMCSDR = (SDR_type_12h_t*) &SDRtbl[i1];
			  pMMCSDR->slaveaddr = curipmbladdr;
			  pMMCSDR->entityinstance = curentityinstance;
			  break;
			  
		  default:
		    break;
    }
  }

  // initialize sensor change mask to prompt it to read handle state at startup
  sensor_change_mask = SENS_UPDATE_MSK_HANDLE;

  event_update_flag = 0;
  memset((void*) &PBSrecord, 0, sizeof(PBS_sensor_record_t));
  
  // initalize the sensor table
  initialize_sensor_table();

  // initialize ejection handle callback
  register_eject_handle_change_callback(eject_handle_pos_change);

  // initialize ADC callback code
  adc_register_convert_complete_callback(internal_ADC_convert_complete);

  // initialize SDR state record
  SDRstate.sensor_cnt = 0;
  SDRstate.SDR_cnt = 0;
  for (i1=0; i1<MAX_SENSOR_CNT; i1++)
    if (SensorData[i1].pSDR != NULL)
	    SDRstate.sensor_cnt++;                    // bump number of defined sensors

		
	for (i1=0; i1<MAX_SDR_REC_CNT; i1++)
    if ((SDRtbl[i1].hdr.recID_LSB != 0xff) || (SDRtbl[i1].hdr.recID_MSB != 0xff))
		  // non-empty SDR record
	    SDRstate.SDR_cnt++;  
	SDRstate.SDRreservationID = 0;
}


void sensor_service(void) {
  CAPBUF1_SAVEPC;
  // inspect sensor update mask fields for sensor groups that have a change at the hardware level
  // ejection handle
  if (sensor_change_mask & SENS_UPDATE_MSK_HANDLE) {
    // have handle change
    Disable_global_interrupt();
    sensor_change_mask &= ~SENS_UPDATE_MSK_HANDLE;          // clear mask bit
    Enable_global_interrupt();
	  eject_handle_read();
  }

  // inspect mask for internal ADC timer conversion complete signal
  // processing of all sensors is keyed off of the regularly recurring internal ADC (10 Hz, nominal)
  if (sensor_change_mask & SENS_UPDATE_MSK_INT_ADC) {
    Disable_global_interrupt();
    sensor_change_mask &= ~SENS_UPDATE_MSK_INT_ADC;          // clear mask bit
    Enable_global_interrupt();
	  readout_external_ADC();
    payload_based_sensor_read();                              // read payload (ZYNQ) based sensor values
    Process_Sensors(event_update_flag);
	  event_update_flag = 0;
	}
}


void initialize_sensor_table(void) {
  int i1;
  int ADC_ch;

  // initialize sensor data table
  memset((void*) &SensorData[0], 0, sizeof(sensor_data_tbl_t));
  SensorData[HOTSWAP_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_HOTSWAP_SENSOR];
  SensorData[HOTSWAP_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[HOTSWAP_SENSOR].active_context_code = SENSORACTV_ALWAYS;
  SensorData[HOTSWAP_SENSOR].send_event_function = send_discrete_sensor_event;
  
  SensorData[LOWER_TEMP_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[LOWER_TEMP_SENSOR].readout_func_arg = IADC_CH7;
  SensorData[LOWER_TEMP_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_LOWER_TEMP_SENSOR];
  SensorData[LOWER_TEMP_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[LOWER_TEMP_SENSOR].active_context_code = SENSORACTV_ALWAYS;
  SensorData[LOWER_TEMP_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[UPPER_TEMP_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[UPPER_TEMP_SENSOR].readout_func_arg = IADC_CH6;      // point to same sensor for now
  SensorData[UPPER_TEMP_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_UPPER_TEMP_SENSOR];
  SensorData[UPPER_TEMP_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[UPPER_TEMP_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[UPPER_TEMP_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[PAYLOAD_12V_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[PAYLOAD_12V_SENSOR].readout_func_arg = IADC_CH0;
  SensorData[PAYLOAD_12V_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_PAYLOAD_12V_SENSOR];
  SensorData[PAYLOAD_12V_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[PAYLOAD_12V_SENSOR].active_context_code = SENSORACTV_PAYLOADPWRON;
  SensorData[PAYLOAD_12V_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_3p3V_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_3p3V_SENSOR].readout_func_arg = IADC_CH2;
  SensorData[BKEND_3p3V_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_3p3V_SENSOR];
  SensorData[BKEND_3p3V_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_3p3V_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_3p3V_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_5V_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_5V_SENSOR].readout_func_arg = IADC_CH1;
  SensorData[BKEND_5V_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_5V_SENSOR];
  SensorData[BKEND_5V_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_5V_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_5V_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_1p8V_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_1p8V_SENSOR].readout_func_arg = IADC_CH4;
  SensorData[BKEND_1p8V_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p8V_SENSOR];
  SensorData[BKEND_1p8V_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_1p8V_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_1p8V_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_1p5V_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_1p5V_SENSOR].readout_func_arg = XADC_CH6;
  SensorData[BKEND_1p5V_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p5V_SENSOR];
  SensorData[BKEND_1p5V_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_1p5V_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_1p5V_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_1p0VDD_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_1p0VDD_SENSOR].readout_func_arg = XADC_CH7;
  SensorData[BKEND_1p0VDD_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p0VDD_SENSOR];
  SensorData[BKEND_1p0VDD_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_1p0VDD_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_1p0VDD_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_1p2VDD_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_1p2VDD_SENSOR].readout_func_arg = XADC_CH5;
  SensorData[BKEND_1p2VDD_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p2VDD_SENSOR];
  SensorData[BKEND_1p2VDD_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_1p2VDD_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_1p2VDD_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_1p2VSC_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_1p2VSC_SENSOR].readout_func_arg = XADC_CH2;
  SensorData[BKEND_1p2VSC_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p2VSC_SENSOR];
  SensorData[BKEND_1p2VSC_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_1p2VSC_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_1p2VSC_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[BKEND_1p0MGT_SENSOR].readout_function = get_adc_channel_sensor_readout_value;
  SensorData[BKEND_1p0MGT_SENSOR].readout_func_arg = XADC_CH0;
  SensorData[BKEND_1p0MGT_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p0MGT_SENSOR];
  SensorData[BKEND_1p0MGT_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[BKEND_1p0MGT_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[BKEND_1p0MGT_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[PGOOD_SENSOR].readout_function = get_GPIO_sensor_readout_value;
  SensorData[PGOOD_SENSOR].readout_func_arg = PWRGOOD;
  SensorData[PGOOD_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_PGOOD_SENSOR];
  SensorData[PGOOD_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[PGOOD_SENSOR].active_context_code = SENSORACTV_PAYLOADPWRON;
  SensorData[PGOOD_SENSOR].send_event_function = send_discrete_sensor_event;

  SensorData[ALARM_LEVEL_SENSOR].readout_function = get_Alarm_Level_sensor_value;
  SensorData[ALARM_LEVEL_SENSOR].readout_func_arg = 0;
  SensorData[ALARM_LEVEL_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ALARM_LEVEL_SENSOR];
  SensorData[ALARM_LEVEL_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[ALARM_LEVEL_SENSOR].active_context_code = SENSORACTV_ALWAYS;
  SensorData[ALARM_LEVEL_SENSOR].send_event_function = send_discrete_sensor_event;

  SensorData[FPGA_CONFIG_SENSOR].readout_function = NULL;
  SensorData[FPGA_CONFIG_SENSOR].readout_func_arg = 0;
  SensorData[FPGA_CONFIG_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_FPGA_CONFIG_SENSOR];
  SensorData[FPGA_CONFIG_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[FPGA_CONFIG_SENSOR].active_context_code = SENSORACTV_BACKENDPWRON;
  SensorData[FPGA_CONFIG_SENSOR].send_event_function = send_discrete_sensor_event;

  // calculate scaling factors for all sensors that read ADC channels (internal or external)
  // these scaling factors are stored in the ADC driver module but are called
  // here because they link the SDR scaling factors to the board scaling factors for
  // fast, fixed-point conversion of raw ADC values to SDR-defined 8 bit sensor values
  // for readout and threshold comparison.
  for (i1=FIRST_ANALOG_SENSOR; i1<=LAST_ANALOG_SENSOR; i1++) {
    if (SensorData[i1].readout_function != NULL) {
		  ADC_ch = SensorData[i1].readout_func_arg;
      // determine min and max values (in mV) from SDR and use them to update the scaling factors
      calc_adc_readout_scaling_factors(SensorData[i1].pSDR, &ADCscaletbl[ADC_ch], &ADCreadouttbl[ADC_ch], get_full_scale_lsb(ADC_ch), get_full_scale_mV(ADC_ch));
	  }	  
  }

  // initialize payload-based-sensors
  SensorData[ZYNQ_DIE_TEMP_SENSOR].readout_function = get_pbs_readout_value;
  SensorData[ZYNQ_DIE_TEMP_SENSOR].readout_func_arg = PBS_OFFSET_ZYNQ_DIE;
  SensorData[ZYNQ_DIE_TEMP_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ZYNQ_DIE_TEMP_SENSOR];
  SensorData[ZYNQ_DIE_TEMP_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[ZYNQ_DIE_TEMP_SENSOR].active_context_code = SENSORACTV_PAYLOADSOURCED;
  SensorData[ZYNQ_DIE_TEMP_SENSOR].send_event_function = send_threshold_sensor_event;

  SensorData[ZYNQ_1P0VDD_SENSOR].readout_function = get_pbs_readout_value;
  SensorData[ZYNQ_1P0VDD_SENSOR].readout_func_arg = PBS_OFFSET_ZYNQ_1P0VDD;
  SensorData[ZYNQ_1P0VDD_SENSOR].pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ZYNQ_1P0VDD_SENSOR];
  SensorData[ZYNQ_1P0VDD_SENSOR].event_msg_ctl = SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK;
  SensorData[ZYNQ_1P0VDD_SENSOR].active_context_code = SENSORACTV_PAYLOADSOURCED;
  SensorData[ZYNQ_1P0VDD_SENSOR].send_event_function = send_threshold_sensor_event;
}


void build_default_SDR_image(void) {
  int i1;
  SDR_type_01h_t* pSDR;
  SDR_type_12h_t* pSDRm;
  unsigned short event_mask;

  // builds the default SDR image in RAM
  memset((void*) &SDRtbl, 0, sizeof(SDR_table_t));

  // preset the LSB and USB of all recID's to 0xffff to indicate that they are unused
  // Marking them in this way will help the SDR readout commands correctly navigate the SDR
  // table during readout by the Shelf Manager
  for (i1=0; i1<MAX_SDR_REC_CNT; i1++) {
	  SDRtbl[i1].hdr.recID_LSB = 0xff;
	  SDRtbl[i1].hdr.recID_MSB = 0xff;
  }

   // MMC SDR
  pSDRm = (SDR_type_12h_t*) &SDRtbl[SDR_MMC];
  pSDRm->hdr.recID_LSB = SDR_MMC;
  pSDRm->hdr.recID_MSB = 0;
  pSDRm->hdr.SDRversion = SDR_VERSION;
  pSDRm->hdr.rectype = 0x12;
  pSDRm->hdr.reclength = sizeof(SDR_type_12h_t)-sizeof(SDR_entry_hdr_t);
  pSDRm->slaveaddr = twi_state.ipmbl_addr;
  pSDRm->device_cap = 0x3b;
  pSDRm->entityID = ENTITY_ID;
  pSDRm->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDRm->IDtypelen = 0xc0|9;
  strcpy(&pSDRm->IDstring[0], "WISC CIOZ");

  // Hotswap Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_HOTSWAP_SENSOR];
  pSDR->hdr.recID_LSB = SDR_HOTSWAP_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = HOTSWAP_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & HOTSWAP_SENSOR) | ((SDR_SYSMGR_CODE_HOTSWAP & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x67;
  pSDR->sensorcap = 0x42;
  pSDR->sensortype = HOTSWAP_SENSOR_TYPE;
  pSDR->event_reading_type = SENSOR_SPECIFIC_READING_TYPE;
  pSDR->assertion_event_mask[LOWBYTE] = 0x1f;
  pSDR->deassertion_event_mask[LOWBYTE] = 0;            // hotswap events are assertion only
   pSDR->IDtypelen = 0xc0|7;
  strcpy(pSDR->IDstring, "Hotswap");


  // Lower Temperature Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_LOWER_TEMP_SENSOR];
  pSDR->hdr.recID_LSB = SDR_LOWER_TEMP_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = LOWER_TEMP_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & LOWER_TEMP_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 1;
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 1;         // degrees C
  pSDR->M = 25;
  pSDR->B = 100;
  pSDR->Rexp_Bexp = 0xe1;
  // reading = (degC) * (25 * RAW_VALUE + 1000) * 0.01   ==> reading = (0.25 * RAW_VALUE + 10) * degC
  // min reading = 10 degC, max reading = 73.75 degC
  pSDR->sensor_max_reading = 0xfc;
  pSDR->upper_nonrecover_thr = 220;       // 65 degrees C
  pSDR->upper_critical_thr = 180;         // 55 degrees C
  pSDR->upper_noncritical_thr = 140;      // 45 degrees C
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|11;
  strcpy(pSDR->IDstring, "Bottom Temp");

  // Upper Temperature Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_UPPER_TEMP_SENSOR];
  pSDR->hdr.recID_LSB = SDR_UPPER_TEMP_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = UPPER_TEMP_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & UPPER_TEMP_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 1;
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 1;         // degrees C
  pSDR->M = 25;
  pSDR->B = 100;
  pSDR->Rexp_Bexp = 0xe1;
  // reading = (degC) * (25 * RAW_VALUE + 1000) * 0.01   ==> reading = (0.25 * RAW_VALUE + 10) * degC
  // min reading = 10 degC, max reading = 73.75 degC
  pSDR->sensor_max_reading = 0xfc;
  pSDR->upper_nonrecover_thr = 220;       // 65 degrees C
  pSDR->upper_critical_thr = 180;         // 55 degrees C
  pSDR->upper_noncritical_thr = 140;      // 45 degrees C
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|8;
  strcpy(pSDR->IDstring, "Top Temp");

  // Payload 12V
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_PAYLOAD_12V_SENSOR];
  pSDR->hdr.recID_LSB = SDR_PAYLOAD_12V_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = PAYLOAD_12V_SENSOR;
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
    SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
    SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;							
  pSDR->M = 6;											
  pSDR->M_tol = 0;											
  pSDR->Rexp_Bexp = 0xe0;	
  // reading = (Volts) * (6 * RAW_VALUE + 0) * 0.01   ==> reading = (0.06 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 15.3 Volts
  pSDR->analog_flags = 7;	
  pSDR->nominal_reading = 210;          // 12.6 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;	
  pSDR->sensor_max_reading = 255;	
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 234;     // 14.04 V
  pSDR->upper_critical_thr = 222;       // 13.32 V
  pSDR->upper_noncritical_thr = 217;    // 13.02 V
  pSDR->lower_noncritical_thr = 170;	  // 10.2 V
  pSDR->lower_critical_thr = 160;	      // 9.6 V
  pSDR->lower_nonrecover_thr = 150;     // 9.96 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|5;
  strcpy(pSDR->IDstring, "+12V");


  // Back End 3.3V
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_3p3V_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_3p3V_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = BKEND_3p3V_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_3p3V_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
    SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
    SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;							
  pSDR->M = 15;											
  pSDR->M_tol = 0;											
  pSDR->Rexp_Bexp = 0xd0;	
  // reading = (Volts) * (15 * RAW_VALUE + 0) * 0.001   ==> reading = (0.015 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 3.825 Volts
  pSDR->analog_flags = 7;	
  pSDR->nominal_reading = 220;          // 3.3V V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;	
  pSDR->sensor_max_reading = 255;	
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 242;     // 3.63 V
  pSDR->upper_critical_thr = 237;       // 3.555 V
  pSDR->upper_noncritical_thr = 231;    // 3.465 V
  pSDR->lower_noncritical_thr = 209;	  // 3.135 V
  pSDR->lower_critical_thr = 203;	      // 3.045 V	
  pSDR->lower_nonrecover_thr = 198;     // 2.97 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|5;
  strcpy(pSDR->IDstring, "+3.3V");


  // Back End 5V
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_5V_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_5V_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = BKEND_5V_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_5V_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
  SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
  SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;
  pSDR->M = 22;
  pSDR->M_tol = 0;
  pSDR->Rexp_Bexp = 0xd0;
  // reading = (Volts) * (22 * RAW_VALUE + 0) * 0.001   ==> reading = (0.022 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 3.825 Volts
  pSDR->analog_flags = 7;
  pSDR->nominal_reading = 227;          // 5.0V V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;
  pSDR->sensor_max_reading = 255;
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 250;     // 5.50V V
  pSDR->upper_critical_thr = 244;       // 5.375 V
  pSDR->upper_noncritical_thr = 238;    // 5.25 V
  pSDR->lower_noncritical_thr = 216;	  // 4.75 V
  pSDR->lower_critical_thr = 210;	      // 4.625 V
  pSDR->lower_nonrecover_thr = 204;     // 4.500 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|5;
  strcpy(pSDR->IDstring, "+5.0V");


  // Back End 1.8V
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p8V_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_1p8V_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = BKEND_1p8V_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_1p8V_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
    SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
    SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;							
  pSDR->M = 83;											
  pSDR->M_tol = 0;											
  pSDR->Rexp_Bexp = 0xc0;	
  // reading = (Volts) * (83 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0083 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 2.11 Volts
  pSDR->analog_flags = 7;	
  pSDR->nominal_reading = 217;          // 1.801 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;	
  pSDR->sensor_max_reading = 255;	
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 239;     // 1.984 V
  pSDR->upper_critical_thr = 234;       // 1.942 V
  pSDR->upper_noncritical_thr = 228;    // 1.892 V
  pSDR->lower_noncritical_thr = 206;	  // 1.710 V
  pSDR->lower_critical_thr = 200;	      // 1.660 V	
  pSDR->lower_nonrecover_thr = 195;     // 1.619 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|5;
  strcpy(pSDR->IDstring, "+1.8V");

  // Back End 1.5V
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p5V_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_1p5V_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = BKEND_1p5V_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_1p5V_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
    SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
    SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
    SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;							
  pSDR->M = 75;											
  pSDR->M_tol = 0;											
  pSDR->Rexp_Bexp = 0xc0;	
  // reading = (Volts) * (75 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0075 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 1.91 Volts
  pSDR->analog_flags = 7;	
  pSDR->nominal_reading = 200;          // 1.500 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;	
  pSDR->sensor_max_reading = 255;	
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 220;     // 1.650 V
  pSDR->upper_critical_thr = 215;       // 1.613 V
  pSDR->upper_noncritical_thr = 210;    // 1.575 V
  pSDR->lower_noncritical_thr = 190;	  // 1.425 V
  pSDR->lower_critical_thr = 185;	      // 1.388 V	
  pSDR->lower_nonrecover_thr = 180;     // 1.350 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|5;
  strcpy(pSDR->IDstring, "+1.5V");

  // Back End 1.0VDD Supply
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p0VDD_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_1p0VDD_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum =BKEND_1p0VDD_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_1p0VDD_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
  SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
  SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;
  pSDR->M = 50;
  pSDR->M_tol = 0;
  pSDR->Rexp_Bexp = 0xc0;
  // reading = (Volts) * (50 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0050 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 1.275 Volts
  pSDR->analog_flags = 7;
  pSDR->nominal_reading = 200;          // 1.000 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;
  pSDR->sensor_max_reading = 255;
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 220;     // 1.100 V
  pSDR->upper_critical_thr = 215;       // 1.075 V
  pSDR->upper_noncritical_thr = 210;    // 1.05 V
  pSDR->lower_noncritical_thr = 190;	  // 0.950 V
  pSDR->lower_critical_thr = 185;	      // 0.925 V
  pSDR->lower_nonrecover_thr = 180;     // 0.900 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|7;
  strcpy(pSDR->IDstring, "+1.0VDD");

  // Back End 1.0V MGT Supply
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p0MGT_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_1p0MGT_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum =BKEND_1p0MGT_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_1p0MGT_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
  SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
  SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;
  pSDR->M = 50;
  pSDR->M_tol = 0;
  pSDR->Rexp_Bexp = 0xc0;
  // reading = (Volts) * (50 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0050 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 1.275 Volts
  pSDR->analog_flags = 7;
  pSDR->nominal_reading = 200;          // 1.000 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;
  pSDR->sensor_max_reading = 255;
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 220;     // 1.100 V
  pSDR->upper_critical_thr = 215;       // 1.075 V
  pSDR->upper_noncritical_thr = 210;    // 1.05 V
  pSDR->lower_noncritical_thr = 190;	  // 0.950 V
  pSDR->lower_critical_thr = 185;	      // 0.925 V
  pSDR->lower_nonrecover_thr = 180;     // 0.900 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|9;
  strcpy(pSDR->IDstring, "+1.0V MGT");

 // Back End 1.2 VDD Supply
 pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p2VDD_SENSOR];
 pSDR->hdr.recID_LSB = SDR_BKEND_1p2VDD_SENSOR;
 pSDR->hdr.recID_MSB = 0;
 pSDR->hdr.SDRversion = SDR_VERSION;
 pSDR->hdr.rectype = 0x01;
 pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
 pSDR->ownerID = twi_state.ipmbl_addr;
 pSDR->sensornum =BKEND_1p2VDD_SENSOR;
 pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_1p2VDD_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
 pSDR->entityID = ENTITY_ID;
 pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
 pSDR->sensorinit = 0x7f;
 pSDR->sensorcap = 0x58;
 pSDR->sensortype = 0x02;                  // type 2 = voltage
 pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
 event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
 SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
 SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
 pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
 pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
 pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
 pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
 pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
 SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
 pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
 SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
 // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
 pSDR->sensor_units_2 = 0x4;
 pSDR->M = 60;
 pSDR->M_tol = 0;
 pSDR->Rexp_Bexp = 0xc0;
 // reading = (Volts) * (60 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0060 * RAW_VALUE) * Volts
 // min reading = 0 Volts, max reading = 1.530 Volts
 pSDR->analog_flags = 7;
 pSDR->nominal_reading = 200;          // 1.200 V
 pSDR->normal_max = 255;
 pSDR->normal_min = 0;
 pSDR->sensor_max_reading = 255;
 pSDR->sensor_min_reading = 0x00;
 pSDR->upper_nonrecover_thr = 220;     // 1.320 V
 pSDR->upper_critical_thr = 215;       // 1.290 V
 pSDR->upper_noncritical_thr = 210;    // 1.260 V
 pSDR->lower_noncritical_thr = 190;	  // 1.140 V
 pSDR->lower_critical_thr = 185;	      // 1.110 V
 pSDR->lower_nonrecover_thr = 180;     // 1.080 V
 pSDR->pos_thr_hysteresis = 2;
 pSDR->neg_thr_hysteresis = 2;
 pSDR->IDtypelen = 0xc0|7;
 strcpy(pSDR->IDstring, "+1.2VDD");

  // Back End 1.2VSC Supply
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_BKEND_1p2VSC_SENSOR];
  pSDR->hdr.recID_LSB = SDR_BKEND_1p2VSC_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum =BKEND_1p2VSC_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & BKEND_1p2VSC_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
  SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
  SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;
  pSDR->M = 60;
  pSDR->M_tol = 0;
  pSDR->Rexp_Bexp = 0xc0;
  // reading = (Volts) * (60 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0060 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 1.530 Volts
  pSDR->analog_flags = 7;
  pSDR->nominal_reading = 200;          // 1.200 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;
  pSDR->sensor_max_reading = 255;
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 220;     // 1.320 V
  pSDR->upper_critical_thr = 215;       // 1.290 V
  pSDR->upper_noncritical_thr = 210;    // 1.260 V
  pSDR->lower_noncritical_thr = 190;	  // 1.140 V
  pSDR->lower_critical_thr = 185;	      // 1.110 V
  pSDR->lower_nonrecover_thr = 180;     // 1.080 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|7;
  strcpy(pSDR->IDstring, "+1.2VSC");

  // Power Good Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_PGOOD_SENSOR];
  pSDR->hdr.recID_LSB = SDR_PGOOD_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = PGOOD_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & PGOOD_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x67;
  pSDR->sensorcap = 0x40;
  pSDR->sensortype = 0x08;        // power supply
  pSDR->event_reading_type = DIGITAL_EVENT_READING_TYPE;
  pSDR->assertion_event_mask[LOWBYTE] = 0x00;
  pSDR->deassertion_event_mask[LOWBYTE] = 0x02;
  pSDR->readable_threshold_mask = 0x03;                       // bottom two events readable
  pSDR->sensor_units_1 = 0xc0;                              // no analog voltage
  pSDR->IDtypelen = 0xc0|8;
  strcpy(pSDR->IDstring, "Pwr Good");

  // Alarm Level Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ALARM_LEVEL_SENSOR];
  pSDR->hdr.recID_LSB = SDR_ALARM_LEVEL_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = ALARM_LEVEL_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & ALARM_LEVEL_SENSOR) | ((SDR_SYSMGR_CODE_ALARM_LVL & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x67;
  pSDR->sensorcap = 0x40;
  pSDR->sensortype = MODULE_BOARD_SENSOR_TYPE;        // module/board
  pSDR->event_reading_type = SEVERITY_EVENT_READING_TYPE;
  pSDR->assertion_event_mask[LOWBYTE] = 0x7f;     // enable bottom 6 offset codes of the ALARMLVL_ type
  pSDR->deassertion_event_mask[LOWBYTE] = 0;      // no deassertion events by default
  pSDR->readable_threshold_mask = 0x07f;          // bottom 7 state bits are used by this sensor
  pSDR->sensor_units_1 = 0xc0;                              // no analog voltage
  pSDR->IDtypelen = 0xc0|11;
  strcpy(pSDR->IDstring, "Alarm Level");

  // FPGA Config Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_FPGA_CONFIG_SENSOR];
  pSDR->hdr.recID_LSB = SDR_FPGA_CONFIG_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = FPGA_CONFIG_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & FPGA_CONFIG_SENSOR) | ((SDR_SYSMGR_CODE_CONFIG & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x67;
  pSDR->sensorcap = 0x40;
  pSDR->sensortype = FPGA_CONFIG_SENSOR_TYPE;        // custom type for the config sensor
  pSDR->event_reading_type = SENSOR_SPECIFIC_READING_TYPE;
  event_mask = (FPGACFGEV_REQCFG0_MASK | FPGACFGEV_CFGRDY0_MASK);
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = 0;  // no deassertion mask bits 
  pSDR->deassertion_event_mask[HIGHBYTE] = 0;
  pSDR->readable_threshold_mask = 0xff;           // bottom 8 state bits are used by this sensor
  pSDR->settable_threshold_mask = 0x03;           // as are the next 3 bits
  pSDR->sensor_units_1 = 0xc0;                              // no analog voltage
  pSDR->IDtypelen = 0xc0|11;
  strcpy(pSDR->IDstring, "FPGA Config");

  // ZYNQ Die Temperature Sensor
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ZYNQ_DIE_TEMP_SENSOR];
  pSDR->hdr.recID_LSB = SDR_ZYNQ_DIE_TEMP_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = ZYNQ_DIE_TEMP_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & ZYNQ_DIE_TEMP_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 1;
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 1;         // degrees C
  pSDR->M = 40;
  pSDR->B = 100;
  pSDR->Rexp_Bexp = 0xe1;
  // reading = (degC) * (40 * RAW_VALUE + 1000) * 0.01   ==> reading = (0.40 * RAW_VALUE + 10) * degC
  // min reading = 10 degC, max reading = 112 degC
  pSDR->sensor_max_reading = 0xfc;
  pSDR->upper_nonrecover_thr = 175;       // 80 degrees C
  pSDR->upper_critical_thr = 150;         // 70 degrees C
  pSDR->upper_noncritical_thr = 125;      // 60 degrees C
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|13;
  strcpy(pSDR->IDstring, "ZYNQ Die Temp");

  
  // ZYNQ 1.0VDD
  pSDR = (SDR_type_01h_t*) &SDRtbl[SDR_ZYNQ_1P0VDD_SENSOR];
  pSDR->hdr.recID_LSB = SDR_ZYNQ_1P0VDD_SENSOR;
  pSDR->hdr.recID_MSB = 0;
  pSDR->hdr.SDRversion = SDR_VERSION;
  pSDR->hdr.rectype = 0x01;
  pSDR->hdr.reclength = sizeof(SDR_type_01h_t)-sizeof(SDR_entry_hdr_t);
  pSDR->ownerID = twi_state.ipmbl_addr;
  pSDR->sensornum = ZYNQ_1P0VDD_SENSOR;
  pSDR->OEM = (SDR_OEM_FIELD_DEV_SENSOR_MASK & ZYNQ_1P0VDD_SENSOR) | ((SDR_SYSMGR_CODE_NONE & SDR_OEM_FIELD_SYSMGR_CODE_MASK) << SDR_OEM_FIELD_SYSMGR_CODE_POS);
  pSDR->entityID = ENTITY_ID;
  pSDR->entityinstance = ENTITY_INSTANCE_BASE + twi_state.slotid;
  pSDR->sensorinit = 0x7f;
  pSDR->sensorcap = 0x58;
  pSDR->sensortype = 0x02;                  // type 2 = voltage
  pSDR->event_reading_type = THRESHOLD_EVENT_READING_TYPE;					// type 1 = thresholds
  event_mask = SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK | SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK |
  SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK | SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK |
  SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK | SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  pSDR->assertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->assertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->deassertion_event_mask[LOWBYTE] = (unsigned char) (event_mask & 0xff);
  pSDR->deassertion_event_mask[HIGHBYTE] = 0x70 | (unsigned char) (event_mask >> 8);
  pSDR->readable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  pSDR->settable_threshold_mask = SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK | SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK |
  SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK | SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK | SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK;
  // sensor conversion:  reading = (units) * (M * 10^Mexp * RAW_VALUE + B * 10^Bexp) * 10^Rexp
  pSDR->sensor_units_2 = 0x4;
  pSDR->M = 50;
  pSDR->M_tol = 0;
  pSDR->Rexp_Bexp = 0xc0;
  // reading = (Volts) * (50 * RAW_VALUE + 0) * 0.0001   ==> reading = (0.0050 * RAW_VALUE) * Volts
  // min reading = 0 Volts, max reading = 1.275 Volts
  pSDR->analog_flags = 7;
  pSDR->nominal_reading = 200;          // 1.000 V
  pSDR->normal_max = 255;
  pSDR->normal_min = 0;
  pSDR->sensor_max_reading = 255;
  pSDR->sensor_min_reading = 0x00;
  pSDR->upper_nonrecover_thr = 220;     // 1.100 V
  pSDR->upper_critical_thr = 215;       // 1.075 V
  pSDR->upper_noncritical_thr = 210;    // 1.05 V
  pSDR->lower_noncritical_thr = 190;	  // 0.950 V
  pSDR->lower_critical_thr = 185;	      // 0.925 V
  pSDR->lower_nonrecover_thr = 180;     // 0.900 V
  pSDR->pos_thr_hysteresis = 2;
  pSDR->neg_thr_hysteresis = 2;
  pSDR->IDtypelen = 0xc0|12;
  strcpy(pSDR->IDstring, "ZYNQ +1.0VDD");

}


void internal_ADC_convert_complete(void) {
  // called when ADC completes converstion
  sensor_change_mask |= SENS_UPDATE_MSK_INT_ADC;
}


void eject_handle_pos_change(void) {
  sensor_change_mask |= SENS_UPDATE_MSK_HANDLE;
}


unsigned char* get_SDR_entry_addr(int SDRrecordID) {
  // returns the address of the specified SDR record ID as a pointer to unsigned chars.
  // returns NULL if the record is out of range or not defined
  int i1;
  int lclrecID;

  if ((SDRrecordID < 0) || (SDRrecordID > 0xffff))
    return NULL;            // out of valid range

  if (SDRrecordID == 0) {
	  // return first non-empty entry in SDR in table
    for (i1=0; i1 < MAX_SDR_REC_CNT; i1++) {
		  if ((SDRtbl[i1].hdr.recID_LSB != 0xff) || (SDRtbl[i1].hdr.recID_MSB != 0xff))
		    return (unsigned char*) &SDRtbl[i1];        // return this one
	  }    	      		
	  return NULL;          // none found
  }
  
  // look for exact match
  for (i1=0; i1<MAX_SDR_REC_CNT; i1++) {
	  lclrecID = (SDRtbl[i1].hdr.recID_MSB << 8) + SDRtbl[i1].hdr.recID_LSB;
	  if (lclrecID == SDRrecordID)
	    return (unsigned char*) &SDRtbl[i1];
	}
	return NULL;
}


SDR_type_01h_t* get_sensor_SDR_addr(int SensorNum) {
  // returns a pointer to the sensor SDR for a given sensor number.
  // returns NULL if no sensor is found
  if ((SensorNum < 0) || (SensorNum >=MAX_SENSOR_CNT))
    return NULL;
  return SensorData[SensorNum].pSDR;
}


int get_SDR_next_recID(SDR_entry_hdr_t* pCurSDRHdr) {
	SDR_generic_type_t* pgenSDR;
  int recID;

  // check if this is header to last SDR in table if it is, then there are no more by definition
  if (pCurSDRHdr == &SDRtbl[MAX_SDR_REC_CNT-1].hdr)
    return END_OF_SDR_LIST;

  pgenSDR = (SDR_generic_type_t*) pCurSDRHdr;
  pgenSDR++;            // advance to next
  
  while (pgenSDR <= &SDRtbl[MAX_SDR_REC_CNT-1]) {
	  recID = (pgenSDR->hdr.recID_MSB  << 8) + pgenSDR->hdr.recID_LSB;
	  if (recID != 0xffff)
	    return recID;
		pgenSDR++;
	  
  }
  return END_OF_SDR_LIST;               // none found
}

void calc_adc_readout_scaling_factors(const SDR_type_01h_t* pSDR, front_end_scaling_factors_t *pFEscfac, IPMI_readout_scaling_factors_t* pROscfac, long fullscale_lsb, long fullscale_mV) {
  // Calculate the scaling factors for mapping the adc conversion value to the 8-bit raw sensor
  // readout value.  Scaling factors are stored with the adc channel front-end parameters.
  float cursig;
  float lsbpermv = (float) fullscale_lsb / (float) fullscale_mV;
  // propagate signal through transducer/circuit/ADC scaling factors
  cursig = SDR_readout_to_display_val(pSDR, ADC_MIN_READOUT_VAL);
  cursig *= ((float) pFEscfac->Mnum)/((float) pFEscfac->Mdenom);
  cursig += (float) pFEscfac->B;
  pROscfac->ReadoutScalingMinVal = (long) ((cursig * lsbpermv)+.5);
  // propagate signal through transducer/circuit/ADC scaling factors
  cursig = SDR_readout_to_display_val(pSDR, ADC_MAX_READOUT_VAL);
  cursig *= ((float) pFEscfac->Mnum)/((float) pFEscfac->Mdenom);
  cursig += (float) pFEscfac->B;
  pROscfac->ReadoutScalingMaxVal = (long) ((cursig * lsbpermv)+.5);
}


float SDR_readout_to_display_val(const SDR_type_01h_t* pSDR, unsigned char readoutval) {
  float retval, Mf, Rf, Bf;
  long Mi, Bi, Bexp, Rexp;

  Mi = pSDR->M | (((pSDR->M_tol) & 0xc0) << 2);
  if (Mi & 0x200)
    Mi |= 0xfffffc00;     // extend sign bit
  Bi = pSDR->B | (((pSDR->B_accuracy) & 0xc0) << 2);
  if (Bi & 0x200)
    Bi |= 0xfffffc00;     // extend sign bit
  Mf = (float) Mi;
  Bf = (float) Bi;
  Bexp = pSDR->Rexp_Bexp & 0xf;
  if (Bexp & 0x8)
    Bexp |= 0xfffffff0;
  Rexp = pSDR->Rexp_Bexp >> 4;
  if (Rexp & 0x8)
    Rexp |= 0xfffffff0;     // extend sign bit
  Rf = pow(10., ((float) Rexp));
  Bf *= pow(10., (float) Bexp);

  retval = (Mf* ((float) readoutval) + Bf) * Rf;
  return retval;
}


void eject_handle_read(void) {
  // this function gets called when a change in the stable handle position has been detected, 
  // with the change being preliminarily marked in the otherwise unused readout_value field of the Sensor Table
  // Hot swap sensor.  At regular polling time, the change will be collected and used to update the assertion
  // event mask, resulting in the transmission of a hot swap event.
  Eject_Hdl_Pos curpos = get_eject_handle_stable_state();

  if (curpos == in_closed) {
    // handle closed
		update_sensor_discrete_state(HOTSWAP_SENSOR, HOTSWAP_MODULE_HANDLE_OPEN_MASK, HOTSWAP_MODULE_HANDLE_CLOSED_MASK);

    //*** Special Code 19-Apr-2011 for systems with dumb power supplies ***
    //In systems with managed power, the payload power supply will be off when the hotswap
    //handle is closed.  However, on systems with a dumb power supply, this may not be the
    //case, as power is applied as soon as the diode is detected.  This presents a problem
    //as the IPMI spec calls for the Quieced bit in the hotswap sensor to be cleared when
    //payload power turn-on is detected.  Since the state machine uses the Quiesce flag to
    //mask sensor events at system turn-on/turn-off, the possibility exists that if the bit
    //gets set, it will never clear until the module is physically removed.  So this code
    //simulates the normal reapplication of 12V power by sending out a simulated power-on
    //detect event, even though the 12V power never went away (because of the dumb supply).
    if ((pyldmgr_get_payload_power_status() == power_on) && (SensorData[HOTSWAP_SENSOR].cur_masked_comp & HOTSWAP_QUIESCED_MASK))
      post_swevent(PYLDMGREV_PAYLD_PWR_ON_DETECT, NULL);
  }
  else {
    // handle opened
		update_sensor_discrete_state(HOTSWAP_SENSOR, HOTSWAP_MODULE_HANDLE_CLOSED_MASK, HOTSWAP_MODULE_HANDLE_OPEN_MASK);
  }
}


unsigned short get_thr_sensor_state(SDR_type_01h_t* pSDR, unsigned short prev_comp_state, unsigned char raw_value) {
  unsigned short retval = prev_comp_state;
  unsigned char neghyst = pSDR->neg_thr_hysteresis;
  unsigned char poshyst = pSDR->pos_thr_hysteresis;

  if (raw_value >= pSDR->upper_nonrecover_thr)
    retval |= SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  else if (raw_value < pSDR->upper_nonrecover_thr-poshyst)
    retval &= ~SENSOREV_UPPER_NONRECOVER_HIGH_ASSERT_MASK;
  if (raw_value <= pSDR->upper_nonrecover_thr)
    retval |= SENSOREV_UPPER_NONRECOVER_LOW_ASSERT_MASK;
  else if (raw_value > pSDR->upper_nonrecover_thr+neghyst)
    retval &= ~SENSOREV_UPPER_NONRECOVER_LOW_ASSERT_MASK;

  if (raw_value >= pSDR->upper_critical_thr)
    retval |= SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK;
  else if (raw_value < pSDR->upper_critical_thr-poshyst)
    retval &= ~SENSOREV_UPPER_CRITICAL_HIGH_ASSERT_MASK;
  if (raw_value <= pSDR->upper_critical_thr)
    retval |= SENSOREV_UPPER_CRITICAL_LOW_ASSERT_MASK;
  else if (raw_value > pSDR->upper_critical_thr+neghyst)
    retval &= ~SENSOREV_UPPER_CRITICAL_LOW_ASSERT_MASK;

  if (raw_value >= pSDR->upper_noncritical_thr)
    retval |= SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK;
  else if (raw_value < pSDR->upper_noncritical_thr-poshyst)
    retval &= ~SENSOREV_UPPER_NONCRITICAL_HIGH_ASSERT_MASK;
  if (raw_value <= pSDR->upper_noncritical_thr)
    retval |= SENSOREV_UPPER_NONCRITICAL_LOW_ASSERT_MASK;
  else if (raw_value > pSDR->upper_noncritical_thr+neghyst)
    retval &= ~SENSOREV_UPPER_NONCRITICAL_LOW_ASSERT_MASK;

  if (raw_value >= pSDR->lower_nonrecover_thr)
    retval |= SENSOREV_LOWER_NONRECOVER_HIGH_ASSERT_MASK;
  else if (raw_value < pSDR->lower_nonrecover_thr-poshyst)
    retval &= ~SENSOREV_LOWER_NONRECOVER_HIGH_ASSERT_MASK;
  if (raw_value <= pSDR->lower_nonrecover_thr)
    retval |= SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK;
  else if (raw_value > pSDR->lower_nonrecover_thr+neghyst)
    retval &= ~SENSOREV_LOWER_NONRECOVER_LOW_ASSERT_MASK;

  if (raw_value >= pSDR->lower_critical_thr)
    retval |= SENSOREV_LOWER_CRITICAL_HIGH_ASSERT_MASK;
  else if (raw_value < pSDR->lower_critical_thr-poshyst)
    retval &= ~SENSOREV_LOWER_CRITICAL_HIGH_ASSERT_MASK;
  if (raw_value <= pSDR->lower_critical_thr)
    retval |= SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK;
  else if (raw_value > pSDR->lower_critical_thr+neghyst)
    retval &= ~SENSOREV_LOWER_CRITICAL_LOW_ASSERT_MASK;

  if (raw_value >= pSDR->lower_noncritical_thr)
    retval |= SENSOREV_LOWER_NONCRITICAL_HIGH_ASSERT_MASK;
  else if (raw_value < pSDR->lower_noncritical_thr-poshyst)
    retval &= ~SENSOREV_LOWER_NONCRITICAL_HIGH_ASSERT_MASK;
  if (raw_value <= pSDR->lower_noncritical_thr)
    retval |= SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK;
  else if (raw_value > pSDR->lower_noncritical_thr+neghyst)
    retval &= ~SENSOREV_LOWER_NONCRITICAL_LOW_ASSERT_MASK;

  return retval;
}


unsigned char get_GPIO_sensor_readout_value(long pinID) {
	// readout function for a digital sensor.  Uses the argument to return the
	// associated GPIO pin value.  If bit 0x8000 is set, then the 1's complement of
	// the GPIO value should be returned
	unsigned char retval;
	if (pinID & 0x8000)
	  retval = gpio_get_pin_value(pinID & 0xff) ? 0 : 1;
	else
	  retval = gpio_get_pin_value(pinID & 0xff) ? 1 : 0;
	return retval;
}



unsigned char get_Alarm_Level_sensor_value(long arg) {
  // returns the payload manager alarm level as the sensor value
  // where 0 = no alarm (OK), 1 = non-critical, 2 = critical, and 3 = non-recoverable
  return (unsigned char) pyldmgr_state.alarm.cur_alarm_level;
}


void Process_Sensors(int sensor_update_flag) {
	// process each sensor
	
	int i1;
	SDR_type_01h_t* pSDR;
	sensor_data_entry_t* pSD;
  unsigned short assertion_mask, deassertion_mask;
	
	for (i1=0; i1<MAX_SENSOR_CNT; i1++) {
    pSD = &SensorData[i1];                // set pointer
	  if (pSD->pSDR == NULL)
	    // unused table entry
		  continue;
		pSDR = pSD->pSDR;
		
		// update sensor value if appropriate (analog sensors and some digital sensors)
		if (pSD->readout_function != NULL)
		  pSD->readout_value = (*(pSD->readout_function))(pSD->readout_func_arg);

		// capture current state mask
		pSD->prev_masked_comp = pSD->cur_masked_comp;
		
		// check power state of system and determine if sensor is within the proper power context to generate events.
		// If it is out of context, then all states are zeroed out this mechanism prevents below-threshold voltage readings from
		// causing events when the payload or back end power is off
    switch (pSD->active_context_code) {
      case SENSORACTV_ALWAYS:
        break;              // proceed to further event processing
      case SENSORACTV_PAYLOADPWRON:
        if ((pyldmgr_get_payload_power_status() == power_off) || (SensorData[HOTSWAP_SENSOR].cur_masked_comp & HOTSWAP_QUIESCED_MASK)) {
          pSD->cur_masked_comp = 0;         // no thresholds set when payload supply is off or about to be off
          continue;
        }
        break;
      case SENSORACTV_BACKENDPWRON:
        if ((pyldmgr_get_backend_power_status() == power_off) || (SensorData[HOTSWAP_SENSOR].cur_masked_comp & HOTSWAP_QUIESCED_MASK)) {
          pSD->cur_masked_comp = 0;         // no thresholds set when backend power is off or about to be off
          continue;
        }
        break;
      case SENSORACTV_PAYLOADSOURCED:
        // sensor is sourced from payload via MMC SPI interface.  This means that the data may or may not be there depending on the status of the back end.
        // use the readout function argument to check if the last returned value from the MMC-SPI is valid or not
        if (!(PBSrecord.validmask & (1<<pSD->readout_func_arg))) {
          // payload-sourced sensor not currently returning valid data
          pSD->cur_masked_comp = 0;
          continue;
        }
        break;

      case SENSORACTV_NEVER:
      default:
        pSD->cur_masked_comp = 0;         // no thresholds set ever
        continue;    
	  }		
		
		// update state mask, depending on the sensor type
		switch (pSDR->event_reading_type) {
			case THRESHOLD_EVENT_READING_TYPE:
        if ((pSD->pSDR->sensorcap & 0x0c) != 0x00) {
          // sensor has thresholds, apply comparators
          pSD->cur_masked_comp = get_thr_sensor_state(pSD->pSDR, pSD->cur_masked_comp, pSD->readout_value);

          // update comparator status which is returned with IPMI Get Sensor Reading command
          // Per IPMI spec:
          // [7:6] - reserved. Returned as 1b. Ignore on read.
          // [5] - 1b = at or above (>=) upper non-recoverable threshold
          // [4] - 1b = at or above (>=) upper critical threshold
          // [3] - 1b = at or above (>=) upper non-critical threshold
          // [2] - 1b = at or below (<=) lower non-recoverable threshold
          // [1] - 1b = at or below (<=) lower critical threshold
          // [0] - 1b = at or below (<=) lower non-critical threshold
          pSD->comparator_status = 0xc0;
          pSD->comparator_status |= (pSD->readout_value >= pSD->pSDR->upper_nonrecover_thr) ? SENSOREV_UPPER_NONRECOVER_THR_SETREAD_MASK : 0;
          pSD->comparator_status |= (pSD->readout_value >= pSD->pSDR->upper_critical_thr) ? SENSOREV_UPPER_CRITICAL_THR_SETREAD_MASK : 0;
          pSD->comparator_status |= (pSD->readout_value >= pSD->pSDR->upper_noncritical_thr) ? SENSOREV_UPPER_NONCRITICAL_THR_SETREAD_MASK : 0;
          pSD->comparator_status |= (pSD->readout_value <= pSD->pSDR->lower_nonrecover_thr) ? SENSOREV_LOWER_NONRECOVER_THR_SETREAD_MASK : 0;
          pSD->comparator_status |= (pSD->readout_value <= pSD->pSDR->lower_critical_thr) ? SENSOREV_LOWER_CRITICAL_THR_SETREAD_MASK : 0;
          pSD->comparator_status |= (pSD->readout_value <= pSD->pSDR->lower_noncritical_thr) ? SENSOREV_LOWER_NONCRITICAL_THR_SETREAD_MASK : 0;
        }
        else {
          pSD->cur_masked_comp = 0;      // no thresholds
          pSD->comparator_status = 0xc0;
        }
			  break;
			  
			case DIGITAL_EVENT_READING_TYPE:
	      // update event mask per pin value
		    if (pSD->readout_value)
			    pSD->cur_masked_comp = 1 << DIGITALEV_STATE_ASSERTED;
			  else
			    pSD->cur_masked_comp = 1 << DIGITALEV_STATE_DEASSERTED;
				break;
				
			case SENSOR_SPECIFIC_READING_TYPE:
			  switch (pSDR->sensortype) {
          case FPGA_CONFIG_SENSOR_TYPE:
            // config sensor is updated by the autoconfig agent and not a readout function
            // nothing to do here
			    case HOTSWAP_SENSOR_TYPE:
			      // hotswap sensor is updated on an event-driven basis, as opposed to being polled
				    // nothing to do here
				  default:
				    // unknown sensor type
					  break;
			  }
			  break;
			  			
		  case SEVERITY_EVENT_READING_TYPE:
		    // changes to the event mask handled in the payload manager alarm state code
			  // nothing to do here
			default:
			  // unknown reading type, do nothing
			  break;
		}

    // generate sensor events
    // Under normal conditions, only changes in the assertion and deassertion states require events.
    // However at certain times, such as when the Carrier sends a SET_EVENT_RECEIVER command, the MMC is required to send
    // a refresh of all assertion and deassertion events.  The sensor_update_flag argument to this function directs which
    // handling method applies.
	  if (sensor_update_flag) {
	    // report events for all asserted states
      assertion_mask = pSD->cur_masked_comp & (pSD->pSDR->assertion_event_mask[LOWBYTE] | ((pSD->pSDR->assertion_event_mask[HIGHBYTE] & 0xf) << 8));
      process_sensor_events(assert, i1, assertion_mask);
	  }
	  else {
		  // compare current and previous event masks against assertion and deassertion masks, and issue assertion/deassertion events for the sensor		
      assertion_mask = pSD->cur_masked_comp & (~pSD->prev_masked_comp) & (pSD->pSDR->assertion_event_mask[LOWBYTE] | ((pSD->pSDR->assertion_event_mask[HIGHBYTE] & 0xf) << 8));
      deassertion_mask = (~pSD->cur_masked_comp) & pSD->prev_masked_comp & (pSD->pSDR->deassertion_event_mask[LOWBYTE] | ((pSD->pSDR->deassertion_event_mask[HIGHBYTE] & 0xf) << 8));
      process_sensor_events(assert, i1, assertion_mask);
      process_sensor_events(deassert, i1, deassertion_mask);
	  }	  
	
	}
	
}


void process_sensor_events(event_assertion_type_t evtype, int sensornum, unsigned short evtmask) {
  int i1;
  sensor_data_entry_t* pSD;
  if ((sensornum < 0) || (sensornum >= MAX_SENSOR_CNT))
    return;                     // invalid sensor number
  pSD = &SensorData[sensornum];
  if (pSD->pSDR == NULL)
    return;                    // no associated SDR
  if (!(pSD->event_msg_ctl & SENSOREV_MSG_CTL_ENABLE_ALL_EVENTS_MASK))
    return;     // event messages disabled for this sensor
  for (i1=0; i1<=SENSOREV_MAX_OFFSET; i1++)
    if (evtmask & (1<<i1))
      // send sensor event per the function linked to this sensor
      pSD->send_event_function(i1, sensornum, evtype);	  
}


void update_sensor_discrete_state(int sensornum, int deassert_mask, int assert_mask) {
	// function updates the event states for a discrete sensor.  Called when there is a change
	// on the underlying associated signal or state.  First the deassertions are applied, then
	// the assertions.  If multiple bits are to be asserted or deasserted, and the order of
	// associated event transmission is important, then the transitions should be serialized into
	// multiple calls
	sensor_data_entry_t* pSD;
  unsigned short assertion_mask, deassertion_mask;

  if ((sensornum < 0) || (sensornum >= MAX_SENSOR_CNT))
    return;                     // invalid sensor number
  pSD = &SensorData[sensornum];
  if (pSD->pSDR == NULL)
    return;                    // no associated SDR
	
	// update the discrete state
	pSD->prev_masked_comp = pSD->cur_masked_comp;
	pSD->cur_masked_comp &= ~deassert_mask;
	pSD->cur_masked_comp |= assert_mask;
	
	// compare current and previous discrete states to determine which assertion and deassertion event messages need to be transmitted
  assertion_mask = pSD->cur_masked_comp & (~pSD->prev_masked_comp) & (pSD->pSDR->assertion_event_mask[LOWBYTE] | ((pSD->pSDR->assertion_event_mask[HIGHBYTE] & 0xf) << 8));
  deassertion_mask = (~pSD->cur_masked_comp) & pSD->prev_masked_comp & (pSD->pSDR->deassertion_event_mask[LOWBYTE] | ((pSD->pSDR->deassertion_event_mask[HIGHBYTE] & 0xf) << 8));
  process_sensor_events(assert, sensornum, assertion_mask);
  process_sensor_events(deassert, sensornum, deassertion_mask);
}


void send_threshold_sensor_event(int offsetnum, int sensornum, event_assertion_type_t evtype) {
  ipmb_msg_desc_t evtmsg;
	ipmb_init_req_hdr(evtmsg.buf, ipmb_get_event_rcvr_ipmb_addr(), NETFN_SE, ipmb_get_event_rcvr_lun(), 0);
  evtmsg.buf[5] = IPMICMD_SE_PLATFORM_EVENT;
  evtmsg.buf[6] = 0x04;           // event message revision
  evtmsg.buf[7] = SensorData[sensornum].pSDR->sensortype;      // sensor type
  evtmsg.buf[8] = sensornum & 0xff;
  if (evtype == assert)
    evtmsg.buf[9] = 0x7f & SensorData[sensornum].pSDR->event_reading_type;   // bit 7=0 for assertion, event reading type should be 0x01 (threshold)
  else
    evtmsg.buf[9] = 0x80 | SensorData[sensornum].pSDR->event_reading_type;   // bit 7=1 for deassertion, event reading type should be 0x01 (threshold)
  evtmsg.buf[10] = ((unsigned char) offsetnum & 0xf) | 0x50;     // trigger reading in byte 2, threshold in byte 3, event offset bits 0-3
  evtmsg.buf[11] = SensorData[sensornum].readout_value;
  evtmsg.buf[12] = *(((unsigned char*) &(SensorData[sensornum].pSDR->upper_nonrecover_thr)) + (5-(offsetnum>>1)));     // get appropriate threshold for event
  evtmsg.buf[13] = calc_ipmi_xsum(&evtmsg.buf[3], 10);
  evtmsg.len = 14;
  ipmb_send_request(&evtmsg, NULL);
}


void send_discrete_sensor_event(int offsetnum, int sensornum, event_assertion_type_t evtype) {
  ipmb_msg_desc_t evtmsg;
	ipmb_init_req_hdr(evtmsg.buf, ipmb_get_event_rcvr_ipmb_addr(), NETFN_SE, ipmb_get_event_rcvr_lun(), 0);
  evtmsg.buf[5] = IPMICMD_SE_PLATFORM_EVENT;
  evtmsg.buf[6] = 0x04;                                        // Event Message Revision = 0x04 (IPMI spec)
  evtmsg.buf[7] = SensorData[sensornum].pSDR->sensortype;      // sensor type some kind of digital or firmware-related
  evtmsg.buf[8] = sensornum & 0xff;                            // sensor number
  if (evtype == assert)
    evtmsg.buf[9] = 0x7f & SensorData[sensornum].pSDR->event_reading_type;   // bit 7=0 for assertion, event reading type should be 0x01 (threshold)
  else
    evtmsg.buf[9] = 0x80 | SensorData[sensornum].pSDR->event_reading_type;   // bit 7=1 for deassertion, event reading type should be 0x01 (threshold)
  evtmsg.buf[10] = offsetnum & 0xf;                                   // offset value for asserted event
  evtmsg.buf[11] = calc_ipmi_xsum(&evtmsg.buf[3], 8);          // message checksum
  evtmsg.len = 12;
  ipmb_send_request(&evtmsg, NULL);
}


int get_sensor_name_str(int SensorNum, char* pnamestr) {
	// copies the sensor name string with null termination from the associated SDR into the storage location specified as
	// a command argument.  Returns 1 if a name is copied, and 0 if the Sensor Number is out of range or if there is no
	// SDR entry associated with the sensor
	SDR_type_01h_t* pSDR;
	int cpylen;
	if ((SensorNum < 0) || (SensorNum >= SDRstate.sensor_cnt)) {
		return 0;
	}
	pSDR = SensorData[SensorNum].pSDR;
	if (pSDR == NULL)
	  return 0;
	cpylen = pSDR->IDtypelen & 0x1f;
	strncpy(pnamestr, pSDR->IDstring, cpylen);
	pnamestr[cpylen] = 0;         // null terminate
	return 1;
}


void payload_based_sensor_read(void) {
  unsigned char rdbuf[PBS_RECORD_SPI_LENGTH];       // MMC-SPI read buffer
  PBS_sensor_record_t* prdbuf;
  int i1;

  prdbuf = (PBS_sensor_record_t*) &rdbuf[0];        // initialize pointer

  // read payload-based-sensor record via MMC SPI interface
  // check power status first, define record as empty/invalid if payload unavailable
  if ((pyldmgr_get_backend_power_status() == power_off) || (SensorData[HOTSWAP_SENSOR].cur_masked_comp & HOTSWAP_QUIESCED_MASK)) {
    memset((void*) &PBSrecord, 0, sizeof(PBS_sensor_record_t));
    return;
  }
    
  if (!spi1_lock()) {
    // can't get SPI1 (should never happen unless something is fouled up seriously in the code
    memset((void*) &PBSrecord, 0, sizeof(PBS_sensor_record_t));
    return;
  }

  if (!(fpgaspi_slave_detect() & FPGA0_SPI_DETECT_MASK)) {
    // FPGA not booted or does not contain interface core
    memset((void*) &PBSrecord, 0, sizeof(PBS_sensor_record_t));
    spi1_unlock();
    return;
  }

  if (!fpgaspi_data_read(0, &rdbuf[0], PBS_RECORD_SPI_ADDRESS, PBS_RECORD_SPI_LENGTH)) {
    // read failed
    memset((void*) &PBSrecord, 0, sizeof(PBS_sensor_record_t));
    spi1_unlock();
    return;
  }

  PBSrecord.updateflag = prdbuf->updateflag;

  // read successful--transfer contents from read buffer to holding buffer if new data is available
  if (PBSrecord.updateflag) {
    // transfer those bytes with set valid flags
    PBSrecord.validmask = prdbuf->validmask;
    for (i1=0; i1<=PBS_OFFSET_MAX_VAL; i1++)
      if (PBSrecord.validmask & (1<<i1)) 
        // transfer this value from read buf to holding buf
        PBSrecord.pbsval[i1] = prdbuf->pbsval[i1];

    // clear flags in MMC-SPI interface
    prdbuf->updateflag = 0;
    prdbuf->validmask = 0;
    fpgaspi_data_write(0, &rdbuf[0], PBS_RECORD_SPI_ADDRESS, 2);
  }

  spi1_unlock();
}


unsigned char get_pbs_readout_value(long sensornum) {
  if ((sensornum < 0) || (sensornum > PBS_OFFSET_MAX_VAL))
    return 0;       // out of range
  if (PBSrecord.validmask & (1 << sensornum))
    return PBSrecord.pbsval[sensornum];
  return 0;
}


int get_payload_sensor_string(int SensorNum, char* pValuestr) {
	SDR_type_01h_t* pSDR;
	sensor_data_entry_t* pSD;
  float displayval;

  // Uses the SDR definition to crack
  if ((SensorNum < FIRST_SENSOR_NUMBER) || (SensorNum > LAST_SENSOR_NUMBER))
    // sensor out of range
    return 0;

  pSD = &SensorData[SensorNum];

  // make sure it is a PBS sensor
  if (pSD->readout_function != get_pbs_readout_value)
    return 0;

  pSDR = pSD->pSDR;
  displayval = SDR_readout_to_display_val(pSDR, pSD->readout_function(pSD->readout_func_arg));
  sprintf(pValuestr, "%6.2f", displayval);

 return 1;
}





